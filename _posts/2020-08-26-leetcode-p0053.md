---
layout: post
title: Leetcode P0053"Maximum Subarray" 题解
categories: [Leetcode]
description: Leetcode P0053题目分析及解答
keywords: Leetcode, Dynamic Programming
---

博文中会简要介绍Leetcode P0053题目分析及解题思路。

“Maximum Subarray”是一道很有意思的动态规划问题，核心思路是动态规划，而递推表达式比较巧妙。

> Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

核心思路是动态规划，那么我们就需要知道最优子结构是什么，并且递推表达式是什么。

```
    令i是nums的下标，则该题最优子结构是，以nums[i]为结尾的连续的数组的和，而通过每次比较这个和，我们最终可以得到最大的和，即max

    递推表达式则是：
    sum = nums[i], if sum+nums[i] < nums[i]
    这个情况代表的就是sum是个负数而nums[i]是个正数，此时下一次sum的计算以nums[i]为开头比前面的sum要更大，所以舍弃前面计算的sum

    sum += nums[itr]
    即sum在持续增大
```

根据上述的递推表达式和最优子结构，我们就可以得到最终的最大连续子数组的和。

以下是Java的题解代码实现。
```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        
        int itr = 1, sum = nums[0], maxSum = nums[0];
        while (itr < nums.length) {
            if (nums[itr] > sum+nums[itr]) {
                sum = nums[itr];
            }
            else {
                sum += nums[itr];
            }
            
            maxSum = Math.max(maxSum, sum);
            ++itr;
        }
        
        return maxSum;
    }
}
```

以下是C++的题解代码实现。
```cpp
class Solution {
public:
    int totalNQueens(int n) {
        vector<vector<bool>> board(n, vector<bool>(n, false));
        if (n > 0)
            this->Dfs(board, n, 0);
        
        return solutions;
    }
    
private:
    int solutions = 0;
    
    bool Validate(const vector<vector<bool>> &board, int cur_row, int cur_col) {
        int dr[] = {-1, -1, 1, 1, -1, 1, 0, 0};
        int dc[] = {-1, 1, 1, -1, 0, 0, 1, -1};
        int bound = board.size();
        
        for (int di=0; di<8; ++di) {
            int next_row = cur_row+dr[di];
            int next_col = cur_col+dc[di];
            
            while (next_row >= 0 && next_row < bound 
                   && next_col >= 0 && next_col < bound) {
                if (board[next_row][next_col])
                    return false;
                
                next_row += dr[di];
                next_col += dc[di];
            }
        }
        
        return true;
    }
    
    void Dfs(vector<vector<bool>> &board, int n, int cur_row) {
        if (n == 0) {
            this->solutions += 1;
            return;
        }
        else {
            for (int col=0; col<board[0].size(); ++col) {
                if (this->Validate(board, cur_row, col)) {
                    board[cur_row][col] = true;
                    this->Dfs(board, n-1, cur_row+1);
                    board[cur_row][col] = false;
                }
            }
        }
        
        return;
    }
};
```