---
layout: post
title: Leetcode P0089"Gray Code" 题解
categories: [Leetcode]
description: Leetcode P0089题目分析及解答
keywords: Leetcode, Backtracking
---

博文中会简要介绍Leetcode P0089题目分析及解题思路。

“Gray Code”是一道比较难一点的深度优先搜索问题，即回溯法。更准确地说，这道题可以定义为纯粹的递归问题。

深度优先搜索虽然也是递归解法，也是在解决子问题，但是其探索的含义更浓一些，即每次先探索本层结点，然后根据情况探索合法的下层结点。而纯粹的递归问题则专注于将问题分解为子问题，然后解决子问题。前者一般来说对本层还有探索的需求，而后者则是首先递归到最深处，解决最小子问题或者说元问题，然后再从最深处回溯到最上层。

总的来说，回溯法不仅仅包含了深度优先搜索，也包含了类似p0089这样的纯递归问题。在解决问题的时候，想到使用回溯法，不能拘泥于深度优先探索，也要考虑能否直接通过解决最小子问题（元问题）来实现对上层问题的解决。

> The gray code is a binary numeral system where two successive values differ in only one bit.
> 
> Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
> 
> Example 1:
> ```
> Input: 2
> Output: [0,1,3,2]
> 
> Explanation:
> 00 - 0
> 01 - 1
> 11 - 3
> 10 - 2
> 
> For a given n, a gray code sequence may not be uniquely defined.
> For example, [0,2,3,1] is also a valid gray code sequence.
> 
> 00 - 0
> 10 - 2
> 11 - 3
> 01 - 1
> ```

虽然说这道题是纯粹递归问题，但是找到将问题分解成子问题的途径或者说策略也是一个难点。这里最好对格雷码有所了解。我们观察上述样例中的格雷码不难发现如下规律：

```
    n = 1,
    0 -> 1

    n = 2,
    00 -> 01 -> 11 -> 10

    n = 3,
    000 -> 001 -> 011 -> 010 -> 110 -> 111 -> 101 -> 100

    很容易发现，当n=k时，前2^(k-1)个格雷码和n=k-1时的格雷码序列一致，而后面2^(k-1)个格雷码则是前面的序列倒序以后，每个格雷码的第k-1位变为1（第0位是最低位）。  
    举个例子，观察n=3时，前4个和n=2时的序列一致，而第5个是110恰好是第4个格雷码010的第2位变为1。同理第6个是111恰好是第3个格雷码011的第2位变为1。
    这样一来我们就可以得到格雷码的生成方法，也即将问题分解城子问题的策略。
```

以下是Java的题解代码实现。
```java
class Solution {
    public List<Integer> grayCode(int n) {
        int[] codes = new int[(int) Math.pow(2, n)];
        if (n == 0)
            return Arrays.asList(new Integer[] {0});
        
        this.encode(n, codes);
        return Arrays.stream(codes).boxed().collect(Collectors.toList());
    }
    
    private void encode(int n, int[] codes) {
        if (n == 1) {
            codes[0] = 0;
            codes[1] = 1;
        }
        else {
            this.encode(n-1, codes);
            int lastSize = (int) Math.pow(2, n-1);
            for (int idx=lastSize-1; idx>=0; --idx) {
                int next = codes[idx]|(1<<(n-1));
                
                codes[2*lastSize-1-idx] = next;
            }
        }
    }
}
```

以下是C++的题解代码实现。
```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> gray_codes(pow(2, n), 0);
        if (n == 0)
            return vector<int> {0};
        
        this->GenerateGrayCode(n, gray_codes);
        return gray_codes;
    }
    
private:
    void GenerateGrayCode(const int n, vector<int> &gray_codes) {
        if (n == 1) {
            gray_codes[0] = 0;
            gray_codes[1] = 1;
            return;
        }
        else {
            this->GenerateGrayCode(n-1, gray_codes);
            int last_size = pow(2, n-1);
            for (int idx=last_size-1; idx>=0; --idx) {
                int next = (gray_codes[idx]|(1L<<(n-1)));
                gray_codes[2*last_size-idx-1] = next;
            }
            return;
        }
    }
    
};
```