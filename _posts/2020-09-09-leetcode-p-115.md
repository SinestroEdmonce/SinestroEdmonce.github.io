---
layout: post
title: Leetcode P0115"Distinct Subsequences" 题解
categories: [Leetcode]
description: Leetcode P0115题目分析及解答
keywords: Leetcode, Dynamic Programming
---

博文中会简要介绍Leetcode P0115题目分析及解题思路。

“Distinct Subsequences”是一道相对较难但是非常经典的动态规划题目。和它类似的动态规划问题围绕序列和子串做文章，往往和它有着相似的思路。在这篇博文里我会先简单总结类似的这类和序列，或者和子串相关的动态规划问题的基本想法与思路，然后再讲解这道题的思路要点。

### 涉及序列或子串的动态规划问题的一般思路

序列相关的动态规划问题与子串相关的动态规划问题的思路有些许差异，这里分开讲解两个问题的一般思路。

#### 序列相关

`TODO`

#### 子串相关

`TODO`

### 题解

> Given a string S and a string T, count the number of distinct subsequences of S which equals T.
> 
> A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).
> 
> It's guaranteed the answer fits on a 32-bit signed integer.

以下是Java的题解代码实现。
```java
class Solution {
    public int numDistinct(String s, String t) {
        
        int sLen = s.length(), tLen = t.length();
        int[][] dp = new int[sLen+1][tLen+1];
        
        dp[0][0] = 1;
        for (int idx=1; idx<=sLen; ++idx)
            dp[idx][0] = 1;
        
        // DP
        for (int i1=1; i1<=sLen; ++i1) {
            for (int j2=1; j2<=i1 && j2<=tLen; ++j2) {
                dp[i1][j2] = dp[i1-1][j2];
                if (s.charAt(i1-1) == t.charAt(j2-1))
                    dp[i1][j2] += dp[i1-1][j2-1];
            }
        }
        
        return dp[sLen][tLen];
    }
}
```

以下是C++的题解代码实现，下述解法更趋近于递归回溯的思路。
```cpp

```
